#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label visible
                                        ; outside this module

        ORG     1C00h                   ; RAM init
bpm     dw      0x0                     ; initial bpm count
seconds dw      0x0                     ; initial read elapsed seconds       
counter dw      0x0                     ; increase by 1 every 0.1 seconds
;display values
display db  0x09, 0x05, 0x03, 0x12, 0x0E, 0x07 
;digits                   0       1       2       3       4       5       6       7       8       9
digitH          db      0xFC,   0x60,   0xDB,   0xF3,   0x67,   0xB7,   0xBF,   0x80,   0xFF,   0xF7
digitL          db      0x28,   0x20,   0x00,   0x00,   0x00,   0x00,   0x00,   0x28,   0x00,   0x00

        ORG     0FFE8h                  ; vector for TIMER_A0
        DC16    TIMER_A0_ISR            ; set vector for 'TIMER_A0_ISR' routine

        ORG     0FFDAh                  ; Set interrupt vector for input in P1.
        DC16    buttonPress             ; Interrupts generated by Port 1 will
                                        ; be serviced by routine which address
                                        ; is stored at address 0FFDAh of the
                                        ; Interrupt Vector Table (IVT).

        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

        MOV.B   #0, R5                  ; R5 will represent the heart state
        MOV.B   #16, R6                 ; R6 will be used to increase battery counter
        MOV.B   #1, R7                  ; R7 will determine if we will increase odd or even battery pile (1 == odd, 0 == even)

        ;Enable LCD segments 0-21; 26-43
        MOV.W   #0xffff, &LCDCPCTL0
        MOV.W   #0xfc3f, &LCDCPCTL1
        MOV.W   #0x0fff, &LCDCPCTL2
        
UnlockGPIO:                                   ;disable the GPIO power-on default
        BIC.W   #LOCKLPM5, &PM5CTL0           ;high-impedance mode to activate
                                              ;previously configured port settings

        MOV     #TASSEL_2+MC_1+ID_1, &TA0CTL  ;Set timer according to next table
	NOP
        ; Uses SMCLK and up mode
        ; TASSELx        MCx (mode control)                IDx (input divider)
        ; 00 -> TACLK    00 -> Stop                        00 -> /1
        ; 01 -> ACLK     01 -> Up mode (up to TACCR0)      01 -> /2
        ; 10 -> SMCLK    10 -> Continuous (up to 0FFFFh)   10 -> /4
        ; 11 -> INCLK    11 -> Up/down (top on TACCR0)     11 -> /8

        ; period = cycles * divider / SMLCK
        ; Assuming SMLCK = 1 MHz, divider = 2 and period = 0.1 seg
        ; cycles = 50000.  With period = 0.1
        MOV     #50000, &TA0CCR0        ; Set the timer capture compare register 0

        BIC.B   #00000110B, &P1IFG      ; To erase a flag raised before
                                        ; activating the GIE. This help to
                                        ; avoid responding to a push on button
                                        ; previous to program start.

        NOP                             ; NOP before setting GIE required by
                                        ; the architecture
        BIS.W   #GIE,SR 	        ; Interrupts enabled (same as eint)
                                        ; so that the micro reacts to 
                                        ; interrupts
        NOP                             ; Wait after setting interrupt bit

lcdActivation:
        MOV.W   #0x041e, &LCDCCTL0        ;initialize lcd_c
        MOV.W   #0x0208, &LCDCVCTL        ;voltage setted to 2.6V
        MOV.W   #0x8000, &LCDCCPCTL       ;clock sync enable
        MOV.W   #2, &LCDCMEMCTL           ;clear lcd memory
        
        BIS.W   #1, &LCDCCTL0             ;turn lcd on

;button activation
buttonActivation:
        MOV.B   #00000110B, &P1REN        ;enable pull-up/pull-down resistors
        MOV.B   #11111001B, &P1DIR        ;input direction
        MOV.B   #00000110B, &P1OUT        ;set as pull-up   

        BIS.B   #06H, &P1IE             ; Enable interrupt at P1.1 and P1.2
        BIS.B   #06H, &P1IES            ; Set interrupt on high-to-low 
                                        ; transition of P1.1 and P1.2

displayOption:
        MOV.W   #2, &LCDCMEMCTL           ;clear lcd memory

        MOV.B   #1, R4                   ; having 1 in R4 implies that we're in the option menu

        MOV.B   #11111100B, &0xA29       ; display O
        MOV.B   #11001111B, &0xA25       ; display P

        MOV.B   #10000000B, &0xA23       ; display T (opHigh)
        MOV.B   #01010000B, &0xA24       ; display T (opLow)

        MOV.B   #10010000B, &0xA32       ; display I (opHigh)
        MOV.B   #01010000B, &0xA33       ; display I (opLow)

        MOV.B   #11111100B, &0xA2E       ; display O

        MOV.B   #01101100B, &0xA27       ; display N (opHigh)
        MOV.B   #10000010B, &0xA28       ; display N (opLow)
    
//        BIS.W   #LPM0,SR                ; Enter Low Power Mode 0
//        NOP
        
        JMP     $

displayRead:
        MOV.W   #2, &LCDCMEMCTL          ; clear lcd memory
        MOV.B   #2, R4                   ; having 2 in R4 implies that we're in the read menu

        MOV.B   #11001111B, &0xA29       ; display R (opHigh)
        MOV.B   #00000010B, &0xA2A       ; display R (opLow)

        MOV.B   #10011111B, &0xA25       ; display E 

        MOV.B   #11101111B, &0xA23       ; display A

        MOV.B   #11110000B, &0xA32       ; display D (opHigh)
        MOV.B   #01010000B, &0xA33       ; display D (opLow)

        JMP     fin
        
displayLog:
        MOV.W   #2, &LCDCMEMCTL          ; clear lcd memory
        MOV.B   #3, R4                   ; having 3 in R4 implies that we're in the log menu

        MOV.B   #00011100B, &0xA29       ; display L

        MOV.B   #11111100B, &0xA25       ; display O 

        MOV.B   #10111101B, &0xA23       ; display G

        JMP     fin
        
calculateAverageBPM:
        PUSH.W  R8
        PUSH.W  R9
        
        MOV.B   &seconds, R9             ; move current time in seconds to the division denominator
        DEC.B   R9                       ; decrease R9 because the average BPM is going to be based
                                         ; on previous second

        MOV.B   #60, R8                  ; move 60 to the division numerator (we're going to calculate the average BPM based on 60 seconds)
        MOV.B   #0, R10                  ; reset R10 value

        CALL    #divide                  ; divide number
        
        PUSH.W  R8
        
        MOV.W   &bpm, R8                 ; current button presses
        MOV.B   R10, R9                  ; division result
        MOV.B   #0, R10                  ; reset R10
                
        PUSH.W  R9
        
        CALL    #multiplication
        
        POP     R9
        POP     R8
        
        CALL    #bpmRemainder
        CALL    #startDecode
        
        POP     R9
        POP     R8
        
        RET
        
bpmRemainder:
        CMP.B   #0, R8                    ; did the division result had a remainder?
        JZ      return                    ; if not, then return
        MOV.B   &bpm, R8                  ; current button presses
        CALL    #divide                   ; divide number
        RET

multiplication:
        ADD     R8,R10                    ; Ex.    R10 -> R10 + R8 
        DEC     R9                        ; decrease R9
        JNZ     multiplication            ; if R9 == 0, we have finished multiplying  
        RET
        
divide:
        CMP.W   R9, R8                    ; is R8 >= R9?
        JGE     increaseDivResult         ; if so, increase the division result
        RET                               ; we have finished division      
increaseDivResult: 
        SUB.W   R9, R8                    ; Ex.    R8 -> R8 - R9 
        INC.B   R10                       ; Add 1 to R10
        JMP     divide
        
startDecode:
        //push the following registers into the stack to avoid scondary effects
        MOV.B   #11110001B,&0xA32         ; display B (opHigh)
        MOV.B   #01010000B,&0xA33         ; display B (opLow)
        
        MOV.B   #11001111B,&0xA2E         ; display P (opHigh)
        
        MOV.B   #01101100B,&0xA27         ; display M (opHigh)
        MOV.B   #10100000B,&0xA28         ; display M (opLow)
        
        PUSH.B  R5                        ; push R5 to avoid secondary effects
        PUSH.B  R8
        PUSH.B  R9
        PUSH.B  R10
        
        MOV     #2, R5                    ; 3th index of the display array, let's start showing the decoded value from right to left
decodeValue:
        MOV.W   R10, R8                   ; move the result to the numerator (R8 will be used as the numerator to divide)
        MOV.W   #0, R10                   ; R10 will store the division result, right now is 0
        MOV.W   #10, R9                   ; we're going to divide the result by 10 to start decoding the number in the screen

        CALL    #divide                   ; divide R8/R9, where R9 = 10

        PUSH.W  R5                        ; push R5 to avoid secondary effects

        MOV.B   display(R5), R5           ; the display memory location will be stored in R5
        MOV.B   digitH(R8), 0xA20(R5)     ; activate the digitH segment of the number stored in R9
        MOV.B   digitL(R8), 0xA20+1(R5)   ; activate the digitL segment of the number stored in R9

        POP     R5                        ; pop R5 to avoid secondary effects


        DEC    R5                         ; pass to the next display
        
        CMP     #0, R5                    ; is the division result == 0?
        JGE      decodeValue              ; if not, decode the next value
        //pop the following registers from the stack to restore their original value
        POP     R10
        POP     R9
        POP     R8
        POP     R5                        ; pop R5 to restore previous value

        RET 
        
return:
        RET      
        
detectPulse:
        MOV.W   #2, &LCDCMEMCTL           ; clear lcd memory
        BIS.W   #CCIE, &TA0CCTL0          ; activate timer interrupt

        MOV.B   #4, R4                    ; having 4 in R4 implies that we're taking your pulse

        MOV.B   R6, &0xA31                ; display battery brackets

        JMP     fin
        
increasePulse:
        MOV.B   #2, R5                    ; having a 2 in R5 implies that after two timer interrupts,
                                          ; the heart will be turned off
        INC.W   &bpm                      ; increase button presses

        JMP     fin

buttonPress:        
        BIT.B   #00000010B, &P1IFG        ; was left button pressed?
        JNZ     leftButtonPress           ; then let's determine which operation to do
        BIT.B   #00000100B, &P1IFG        ; was right button pressed?
        JNZ     rightButtonPress          ; then let's determine which operation to do

        JMP     fin
        
TIMER_A0_ISR:
        CALL    #checkHeartTime
        CALL    #increaseCounter

        RETI
        
increaseCounter:
        INC     counter
        CMP     #10, counter             ; is counter == 10?
        JZ      increaseBattery
        RET
        
increaseBattery:       
        MOV.B   #0, counter              ; reset counter to 0
        INC.B   &seconds

        CMP.B   #224, &0xA2D             ; is the battery already full?
        JZ      resetBattery             ; then reset it!       
        
        CMP.B   #1, R7                   ; should we increase odd or even value?
        JZ      impar                    ; if previous condition is true, increase odd value!
par:        
        ADD.B   R6, &0xA2D               ; pass the value in R5 to the even position
        MOV.B   #1, R7                   ; next move will be an odd battery pile
        RET
        
impar:
        ADD.B   R6, R6                   ; multiply R6 * 2
        ADD.B   R6, &0xA31               ; pass the value in R5 to the odd position
        MOV.B   #0, R7                   ; next move will be an even battery pile
        RET
        
resetBattery:
        CALL    #calculateAverageBPM    ; calculate the avergae BPM at the moment
        MOV.B   #32, R6                 ; R6 reset value
        MOV.B   #0, R7                  ; R7 reset value
        MOV.B   #48, &0xA31             ; only one battery pile
        MOV.B   #0, &0xA2D              ; no par battery at the moment
        RET

checkHeartTime:
        CMP.B   #0, R5                   ; is R5 == 0?
        JEQ     turnOffHeart             ; if so? then turn off the heart!

        DEC     R5                       ; if not, then dec R5 
turnOnHeart:
        MOV.B   #4, &0xA22               ; turn on heart
        RET

turnOffHeart:
        MOV.B   #0, &0xA22               ; turn off heart
        RET
        
leftButtonPress:
        CMP.B   #2, R4                   ;are we in the read menu?
        JZ      detectPulse              ;if so, display log
        CMP.B   #4, R4                   ;are we in the pulse menu?
        JZ      increasePulse            ;if so, display the heart

        JMP      fin
        
rightButtonPress:
        CMP.B   #1, R4                   ;are we in the options menu?
        JZ      displayRead              ;if so, display read
        CMP.B   #2, R4                   ;are we in the read menu?
        JZ      displayLog               ;if so, display log
        CMP.B   #3, R4                   ;are we in the log menu?
        JZ      displayRead              ;if so, display read

fin:
        BIC.B   #00000110B, &P1IFG
        NOP
        RETI
        
        END
