#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label visible
                                        ; outside this module

        ORG     0FFE8h                  ; vector for TIMER_A0
        DC16    TIMER_A0_ISR            ; set vector for 'TIMER_A0_ISR' routine

        ORG     0FFDAh                  ; Set interrupt vector for input in P1.
        DC16    buttonPress             ; Interrupts generated by Port 1 will
                                        ; be serviced by routine which address
                                        ; is stored at address 0FFDAh of the
                                        ; Interrupt Vector Table (IVT).

        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

        ORG     1C00h                   ; RAM init
avgBPM  dw      0x0                     ; initial AVG BPM
bpm     db      0x0                     ; initial bpm count
seconds db      0x0                     ; initial read elapsed seconds       
counter db      0x0                     ; increase by 1 every 0.1 seconds
;display values
display db      0x09, 0x05, 0x03        ; we're allowed to display a maximum bpm of three digits
;digits           0       1       2       3       4       5       6       7       8       9
digitH  db      0xFC,   0x60,   0xDB,   0xF3,   0x67,   0xB7,   0xBF,   0x80,   0xFF,   0xF7
digitL  db      0x28,   0x20,   0x00,   0x00,   0x00,   0x00,   0x00,   0x28,   0x00,   0x00

init:   MOV     #SFE(CSTACK), SP        ; set up stack
        
        //reset the following values since they could have been updated
        MOV.B   #0, &avgBPM
        MOV.B   #0, &bpm
        MOV.B   #0, &seconds
        MOV.B   #0, &counter
        
main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

        MOV.B   #0, R5                  ; R5 will represent the heart state
        MOV.B   #16, R6                 ; R6 will be used to increase battery counter
        MOV.B   #1, R7                  ; R7 will determine if we will increase odd or even battery pile (1 == odd, 0 == even)

        ;Enable LCD segments 0-21; 26-43
        MOV.W   #0xffff, &LCDCPCTL0
        MOV.W   #0xfc3f, &LCDCPCTL1
        MOV.W   #0x0fff, &LCDCPCTL2
        
UnlockGPIO:                                   ;disable the GPIO power-on default
        BIC.W   #LOCKLPM5, &PM5CTL0           ;high-impedance mode to activate
                                              ;previously configured port settings

        MOV     #TASSEL_2+MC_1+ID_1, &TA0CTL  ;Set timer according to next table
	NOP
        ; Uses SMCLK and up mode
        ; TASSELx        MCx (mode control)                IDx (input divider)
        ; 00 -> TACLK    00 -> Stop                        00 -> /1
        ; 01 -> ACLK     01 -> Up mode (up to TACCR0)      01 -> /2
        ; 10 -> SMCLK    10 -> Continuous (up to 0FFFFh)   10 -> /4
        ; 11 -> INCLK    11 -> Up/down (top on TACCR0)     11 -> /8

        ; period = cycles * divider / SMLCK
        ; Assuming SMLCK = 1 MHz, divider = 2 and period = 0.1 seg
        ; cycles = 50000.  With period = 0.1
        MOV     #50000, &TA0CCR0        ; Set the timer capture compare register 0

        BIC.B   #00000110B, &P1IFG      ; To erase a flag raised before
                                        ; activating the GIE. This help to
                                        ; avoid responding to a push on button
                                        ; previous to program start.

        NOP                             ; Wait after setting interrupt bit

        MOV.W   #0x041e, &LCDCCTL0        ;initialize lcd_c
        MOV.W   #0x0208, &LCDCVCTL        ;voltage setted to 2.6V
        MOV.W   #0x8000, &LCDCCPCTL       ;clock sync enable
        MOV.W   #2, &LCDCMEMCTL           ;clear lcd memory
        
        BIS.W   #1, &LCDCCTL0             ;turn lcd on

        MOV.B   #06H, &P1REN            ;enable pull-up/pull-down resistors
        MOV.B   #11111001B, &P1DIR      ;input direction
        MOV.B   #06H, &P1OUT            ;set as pull-up   

        BIS.B   #06H, &P1IE             ; Enable interrupt at P1.1 and P1.2
        BIS.B   #06H, &P1IES            ; Set interrupt on high-to-low 
                                        ; transition of P1.1 and P1.2

        CALL    #displayOption

        NOP                              ; NOP required before GIE         
        BIS.W   #GIE+LPM0,SR             ; Interrupts enabled (same as eint) + Enter Low Power Mode 0
        NOP

displayOption:
        MOV.W   #2, &LCDCMEMCTL          ; clear lcd memory

        MOV.B   #1, R4                   ; having 1 in R4 implies that we're in the option menu

        MOV.B   #11111100B, &0xA29       ; display O
        MOV.B   #11001111B, &0xA25       ; display P

        MOV.B   #10000000B, &0xA23       ; display T (opHigh)
        MOV.B   #01010000B, &0xA24       ; display T (opLow)

        MOV.B   #10010000B, &0xA32       ; display I (opHigh)
        MOV.B   #01010000B, &0xA33       ; display I (opLow)

        MOV.B   #11111100B, &0xA2E       ; display O

        MOV.B   #01101100B, &0xA27       ; display N (opHigh)
        MOV.B   #10000010B, &0xA28       ; display N (opLow)

        RET

displayRead:
        MOV.W   #2, &LCDCMEMCTL          ; clear lcd memory
        MOV.B   #2, R4                   ; having 2 in R4 implies that we're in the read menu

        MOV.B   #11001111B, &0xA29       ; display R (opHigh)
        MOV.B   #00000010B, &0xA2A       ; display R (opLow)

        MOV.B   #10011111B, &0xA25       ; display E 

        MOV.B   #11101111B, &0xA23       ; display A

        MOV.B   #11110000B, &0xA32       ; display D (opHigh)
        MOV.B   #01010000B, &0xA33       ; display D (opLow)

        CALL    #delay                   ; let's avoid unnecessary jumps

        JMP     fin
        
displayLog:
        MOV.W   #2, &LCDCMEMCTL          ; clear lcd memory
        MOV.B   #3, R4                   ; having 3 in R4 implies that we're in the log menu

        MOV.B   #00011100B, &0xA29       ; display L

        MOV.B   #11111100B, &0xA25       ; display O 

        MOV.B   #10111101B, &0xA23       ; display G

        CALL    #delay                   ; let's avoid unnecessary jumps

        JMP     fin
        
displaySave:
        MOV.W   #2, &LCDCMEMCTL          ; clear lcd memory
        MOV.B   #6, R4                   ; having 6 in R4 implies that we're in the save menu

        MOV.B   #10110111B, &0xA29       ; display S

        MOV.B   #11101111B, &0xA25       ; display A

        MOV.B   #00001100B, &0xA23       ; display V (opHigh)   
        MOV.B   #00101000B, &0xA24       ; display V (opLow)
  
        MOV.B   #10011111B, &0xA32       ; display E

        CALL    #delay                   ; let's avoid unnecessary jumps
        
        JMP     fin
        
        
calculateAverageBPM:
        PUSH.W  R8
        PUSH.W  R9
        PUSH.W  R10
        
        MOV.B   &seconds, R9             ; move current time in seconds to the division denominator
        DEC.B   R9                       ; decrease R9 because the average BPM is going to be based
                                         ; on previous second

        MOV.B   #60, R8                  ; move 60 to the division numerator (we're going to calculate the average BPM based on 60 seconds)
        MOV.B   #0, R10                  ; reset R10 value

        CALL    #divide                  ; divide number
        
        PUSH.W  R8
        
        MOV.B   &bpm, R8                 ; current button presses
        MOV.B   R10, R9                  ; division result
        MOV.B   #0, R10                  ; reset R10
                
        PUSH.W  R9
        
        CALL    #multiplication          ; multiply current BPM * (60/seconds)
        
        POP     R9
        POP     R8
        
        MOV.W   R10, &avgBPM              ; very unlikely, but just in case, it will be used if BPM number > 256
        
        CALL    #bpmRemainder
        CALL    #startDecode
        
        POP     R9
        POP     R8
        POP     R10
        
        RET
        
bpmRemainder:
        CMP.B   #0, R8                    ; did the division result had a remainder?
        JZ      return                    ; if not, then return
        MOV.B   &bpm, R8                  ; current button presses
        CALL    #divide                   ; divide number
        RET

multiplication:
        ADD     R8,R10                    ; Ex.    R10 -> R10 + R8 
        DEC     R9                        ; decrease R9
        JNZ     multiplication            ; if R9 == 0, we have finished multiplying  
        RET
        
divide:
        CMP     R9, R8                    ; is R8 < R9?
        JN      return                    ; if so, then we have finished division    
        SUB     R9, R8                    ; Ex.    R8 -> R8 - R9 
        INC     R10                       ; Add 1 to R10
        JMP     divide
        
startDecode:
        //push the following registers into the stack to avoid secondary effects
        MOV.B   #11110001B,&0xA32         ; display B (opHigh)
        MOV.B   #01010000B,&0xA33         ; display B (opLow)
        
        MOV.B   #11001111B,&0xA2E         ; display P (opHigh)
        
        MOV.B   #01101100B,&0xA27         ; display M (opHigh)
        MOV.B   #10100000B,&0xA28         ; display M (opLow)
        
        PUSH.B  R5                        ; push R5 to avoid secondary effects
        PUSH.B  R8
        PUSH.B  R9
        PUSH.B  R10
        
        MOV     #2, R5                    ; 2nd index of the display array, let's start showing the decoded value from right to left
decodeValue:
        MOV.W   R10, R8                   ; move the result to the numerator (R8 will be used as the numerator to divide)
        MOV.W   #0, R10                   ; R10 will store the division result, right now is 0
        MOV.W   #10, R9                   ; we're going to divide the result by 10 to start decoding the number in the screen

        CALL    #divide                   ; divide R8/R9, where R9 = 10

        PUSH.W  R5                        ; push R5 to avoid secondary effects

        MOV.B   display(R5), R5           ; the display memory location will be stored in R5
        MOV.B   digitH(R8), 0xA20(R5)     ; activate the digitH segment of the number stored in R9
        MOV.B   digitL(R8), 0xA20+1(R5)   ; activate the digitL segment of the number stored in R9

        POP     R5                        ; pop R5 to avoid secondary effects


        DEC    R5                         ; pass to the next display
        
        CMP.B   #0, R5                    ; is the display index >= 0?
        JGE     decodeValue               ; if so, decode the next value
        //pop the following registers from the stack to restore their original value
        POP     R10
        POP     R9
        POP     R8
        POP     R5                        ; pop R5 to restore previous value

        RET 
        
return:
        RET      
        
detectPulse:
        MOV.W   #2, &LCDCMEMCTL           ; clear lcd memory
        BIS.W   #CCIE, &TA0CCTL0          ; activate timer interrupt

        MOV.B   #4, R4                    ; having 4 in R4 implies that we're taking your pulse

        MOV.B   R6, &0xA31                ; display battery brackets

        JMP     fin
        
increasePulse:        
        MOV.B   #2, R5                    ; having a 2 in R5 implies that after two timer interrupts,
                                          ; the heart will be turned off
        INC.B   &bpm                      ; increase button presses

        JMP     fin

buttonPress:        
        CMP.B   #4, &0xA22                ; is the heart turned on?              
        JEQ     fin                       ; if so, then terminate interuption

        BIT.B   #00000010B, &P1IFG        ; was left button pressed?
        JNZ     leftButtonPress           ; then let's determine which operation to do
        BIT.B   #00000100B, &P1IFG        ; was right button pressed?
        JNZ     rightButtonPress          ; then let's determine which operation to do

        JMP     fin
        
TIMER_A0_ISR:
        CALL    #checkHeartTime
        CALL    #increaseCounter

        RETI
        
increaseCounter:
        INC.B   counter
        CMP.B   #10, counter             ; is counter == 10?
        JZ      increaseBattery
        RET
        
increaseBattery:       
        MOV.B   #0, counter              ; reset counter to 0
        INC.B   &seconds

        CMP.B   #224, &0xA2D             ; is the battery already full?
        JZ      resetBattery             ; then reset it!       
        
        CMP.B   #1, R7                   ; should we increase odd or even value?
        JZ      impar                    ; if previous condition is true, increase odd value!
par:        
        ADD.B   R6, &0xA2D               ; pass the value in R5 to the even position
        MOV.B   #1, R7                   ; next move will be an odd battery pile
        RET
        
impar:
        ADD.B   R6, R6                   ; multiply R6 * 2
        ADD.B   R6, &0xA31               ; pass the value in R5 to the odd position
        MOV.B   #0, R7                   ; next move will be an even battery pile
        RET
        
resetBattery:
        CALL    #calculateAverageBPM     ; calculate the avergae BPM at the moment

        CMP.B   #31,&seconds             ; checks if 30 seconds have past
        JZ      stopPulseMonitor         ; if so, stops the pulse monitor

        MOV.B   #32, R6                  ; R6 reset value
        MOV.B   #0, R7                   ; R7 reset value
        MOV.B   #48, &0xA31              ; only one battery pile
        MOV.B   #0, &0xA2D               ; no par battery at the moment
  
        RET

checkHeartTime:
        CMP.B   #0, R5                   ; is R5 == 0?
        JEQ     turnOffHeart             ; if so? then turn off the heart!

        DEC     R5                       ; if not, then dec R5 
turnOnHeart:
        MOV.B   #4, &0xA22               ; turn on heart
        RET

turnOffHeart:
        MOV.B   #0, &0xA22               ; turn off heart
        RET
        
saveResult:
        PUSH.W    R12
        MOV.W   #1980h, R12              ; move fram address to empty register
        
        MOV.B   0+2(R12), 0+4(R12)       ; store value inside framAddress(2) at address framAddr(4) 
        MOV.B   0+3(R12), 0+5(R12)       ; store value inside framAddress(3) at address framAddr(5) 
        MOV.B   0(R12), 0+2(R12)         ; store value inside framAddress(0) at address framAddr(2)
        MOV.B   0+1(R12), 0+3(R12)       ; store value inside framAddress(1) at address framAddr(3)

        MOV.B   &avgBPM, 0(R12)          ; store LSB of bpm at address framAddr(0), this is the new bpm  
        MOV.B   &avgBPM+1, 0+1(R12)      ; store MSB of bpm at address framAddr(1), this is the new bpm  
                                         ; reading, it effectively removes the oldest one by replacing it
        POP     R12
        JMP     restartMonitor          
        
restartMonitor:
        MOV.B   #0, &bpm                 ;set bpm to 0
        MOV.B   #0, &seconds             ;set seconds to 0
        MOV.B   #0, &counter             ;set counter to 0

        MOV.B   #0, R5                   ;reset R5 to default value
        MOV.B   #16, R6                  ;reset R6 to default value
        MOV.B   #1, R7                   ;reset R7 to default value

        
        CALL    #displayOption           ;display the word OPTIONS

        JMP     fin                      ;clear button flag and return from interrupt

stopPulseMonitor:
        MOV.B   #8, &0xA22               ;turn on clock
        XOR.W   #CCIE, &TA0CCTL0         ;deactivate timer interrupt
        MOV.B   #5, R4                   ;having 5 in R4 means we are in the result menu
        RET
        
leftButtonPress:
        CMP.B   #2, R4                   ;are we in the read menu?
        JZ      detectPulse              ;if so, start running pulse monitor 
        CMP.B   #3, R4                   ;are we in the log menu?
        JZ      displayFram_helper       ;if so, display read bpm's
        CMP.B   #4, R4                   ;are we in the pulse menu?
        JZ      increasePulse            ;if so, display the heart
        CMP.B   #6, R4                   ;are we in save menu?
        JZ      saveResult               ;if so, save result
        CMP.B   #7, R4                   ;are we displaying fram bpm?
        JZ      displayFram              ;if so we keep displaying fram bpm til it resets
        JMP     fin
        
rightButtonPress:
        CMP.B   #1, R4                   ;are we in the options menu?
        JZ      displayRead              ;if so, display read
        CMP.B   #2, R4                   ;are we in the read menu?
        JZ      displayLog               ;if so, display log
        CMP.B   #3, R4                   ;are we in the log menu?
        JZ      displayRead              ;if so, display read
        CMP.B   #5, R4                   ;are we displaying result?
        JZ      displaySave              ;if so, display save
        CMP.B   #6, R4                   ;are we in save menu?
        JZ      restartMonitor           ;restart monitor

        JMP     fin
        
displayFram_helper:
        MOV.B   #7, R4                   ; having 7 in R4 implies that we're displaying past bpr 
        PUSH.W  R11                      ; will be used as a counter for the three bpm in fram
        MOV.W   #1980h, R11              ; start reading from most recent BPM
displayFram:
        MOV.W   #2, &LCDCMEMCTL          ; clear lcd memory
        CMP.W   #1986h, R11              ; did we already passed the oldest BPM registered?
        JZ      clearFramCounter         ; if so, let's exit the BPM log
        MOV.B   0(R11), &avgBPM          ; move LSB of the number that is in memory[R11] to &avgBPM
        CMP.B   #0xFF, 0+1(R11)          ; is the MSB == 0xFF?
        JNZ     displayFram_helper2      ; if so, then apply next instruction
        MOV.B   #0, 0+1(R11)             ; set MSB of the number that is in memory[R11] if prev condition is false
displayFram_helper2:
        MOV.B   0+1(R11), &avgBPM+1      ; move MSB of the number that is in memory[R11] to &avgBPM
        MOV.W   &avgBPM, R10             ; move &avgBPM value to R10 to decode it
        INCD.W  R11                      ; go to next fram address
        CALL    #startDecode             ; display current reading in LCD
        CALL    #delay                   ; let's avoid unnecessary jumps

        JMP     fin                      ; clear flag and return from interrupt

delay:
        PUSH.W  R7                         ;push R7 to reduce secondary effects
        MOV.W   #0xFFFF, R7                ;used to cause delay on R7
keepDelay:
        DEC     R7                         ;increment the value in R7
        JNZ     keepDelay                  ;R7 != 0? call the instruction one more time to cause enough delay
        POP     R7                         ;pop R7 to reduce secondary effects
        RET    

clearFramCounter:
        POP     R11
        CALL    #displayOption
fin:
        BIC.B   #00000110B, &P1IFG      
        NOP                             
        RETI                            
        
        END    
