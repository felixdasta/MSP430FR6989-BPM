#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label visible
                                        ; outside this module

        ORG     0FFE8h                  ; vector for TIMER_A0
        DC16    TIMER_A0_ISR            ; set vector for 'TIMER_A0_ISR' routine

        ORG     0FFDAh                  ; Set interrupt vector for input in P1.
        DC16    buttonPress             ; Interrupts generated by Port 1 will
                                        ; be serviced by routine which address
                                        ; is stored at address 0FFDAh of the
                                        ; Interrupt Vector Table (IVT).

        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

        ;Enable LCD segments 0-21; 26-43
        MOV.W   #0xffff, &LCDCPCTL0
        MOV.W   #0xfc3f, &LCDCPCTL1
        MOV.W   #0x0fff, &LCDCPCTL2
        
UnlockGPIO:                               ;disable the GPIO power-on default
        BIC.W   #LOCKLPM5, &PM5CTL0       ;high-impedance mode to activate
                                          ;previously configured port settings

        BIC.B   #00000110B, &P1IFG      ; To erase a flag raised before
                                        ; activating the GIE. This help to
                                        ; avoid responding to a push on button
                                        ; previous to program start.

        NOP                             ; NOP before setting GIE required by
                                        ; the architecture
        BIS.W   #GIE,SR 	        ; Interrupts enabled (same as eint)
                                        ; so that the micro reacts to 
                                        ; interrupts
        NOP                             ; Wait after setting interrupt bit

lcdActivation:
        MOV.W   #0x041e, &LCDCCTL0        ;initialize lcd_c
        MOV.W   #0x0208, &LCDCVCTL        ;voltage setted to 2.6V
        MOV.W   #0x8000, &LCDCCPCTL       ;clock sync enable
        MOV.W   #2, &LCDCMEMCTL           ;clear lcd memory
        
        BIS.W   #1, &LCDCCTL0             ;turn lcd on

;button activation
buttonActivation:
        MOV.B   #00000110B, &P1REN        ;enable pull-up/pull-down resistors
        MOV.B   #11111001B, &P1DIR        ;input direction
        MOV.B   #00000110B, &P1OUT        ;set as pull-up   

        BIS.B   #06H, &P1IE             ; Enable interrupt at P1.1 and P1.2
        BIS.B   #06H, &P1IES            ; Set interrupt on high-to-low 
                                        ; transition of P1.1 and P1.2

displayOption:
        MOV.W   #2, &LCDCMEMCTL           ;clear lcd memory

        MOV.B   #1, R4                   ; having 1 in R4 implies that we're in the option menu

        MOV.B   #11111100B, &0xA29       ; display O
        MOV.B   #11001111B, &0xA25       ; display P

        MOV.B   #10000000B, &0xA23       ; display T (opHigh)
        MOV.B   #01010000B, &0xA24       ; display T (opLow)

        MOV.B   #10010000B, &0xA32       ; display I (opHigh)
        MOV.B   #01010000B, &0xA33       ; display I (opLow)

        MOV.B   #11111100B, &0xA2E       ; display O

        MOV.B   #01101100B, &0xA27       ; display N (opHigh)
        MOV.B   #10000010B, &0xA28       ; display N (opLow)
    
//        BIS.W   #LPM0,SR                ; Enter Low Power Mode 0
//        NOP
        
        JMP     $

displayRead:
        MOV.W   #2, &LCDCMEMCTL          ; clear lcd memory
        MOV.B   #2, R4                   ; having 2 in R4 implies that we're in the read menu

        MOV.B   #11001111B, &0xA29       ; display R (opHigh)
        MOV.B   #00000010B, &0xA2A       ; display R (opLow)

        MOV.B   #10011111B, &0xA25       ; display E 

        MOV.B   #11101111B, &0xA23       ; display A

        MOV.B   #11110000B, &0xA32       ; display D (opHigh)
        MOV.B   #01010000B, &0xA33       ; display D (opLow)

        JMP     fin
        
displayLog:
        MOV.W   #2, &LCDCMEMCTL          ; clear lcd memory
        MOV.B   #3, R4                   ; having 3 in R4 implies that we're in the log menu

        MOV.B   #00011100B, &0xA29       ; display L

        MOV.B   #11111100B, &0xA25       ; display O 

        MOV.B   #10111101B, &0xA23       ; display G

        JMP     fin
        
detectPulse:
        MOV.W   #2, &LCDCMEMCTL          ; clear lcd memory

        MOV.B   #4, R4                   ; having 4 in R4 implies that we're taking your pulse

        MOV.B   #00010000B, &0xA31       ; display battery brackets

        JMP     fin
        
increasePulse:
        MOV     #TASSEL_2+MC_1+ID_2, &TA0CTL  ;Set timer according to next table
	NOP
        ; Uses SMCLK and up mode
        ; TASSELx        MCx (mode control)                IDx (input divider)
        ; 00 -> TACLK    00 -> Stop                        00 -> /1
        ; 01 -> ACLK     01 -> Up mode (up to TACCR0)      01 -> /2
        ; 10 -> SMCLK    10 -> Continuous (up to 0FFFFh)   10 -> /4
        ; 11 -> INCLK    11 -> Up/down (top on TACCR0)     11 -> /8

        ; period = cycles * divider / SMLCK
        ; Assuming SMLCK = 1 MHz, divider = 8 and period = 0.2 seg
        ; cycles = 25000.  With period = 0.2
        MOV     #50000, &TA0CCR0        ; Set the timer capture compare register 0

        MOV.B   #4, &0xA22               ; turn on heart

        BIS.W   #CCIE, &TA0CCTL0         ; activate timer interrupt
        JMP     fin

buttonPress:        
        BIT.B   #00000010B, &P1IFG       ;was left button pressed?
        JNZ     leftButtonPress          ;then let's determine which operation to do
        BIT.B   #00000100B, &P1IFG       ;was right button pressed?
        JNZ      rightButtonPress        ;then let's determine which operation to do

        JMP     fin
        
TIMER_A0_ISR:
        MOV.B   #0, &0xA22               ; turn off heart

        RETI
        
leftButtonPress:
        CMP.B   #2, R4                   ;are we in the read menu?
        JZ      detectPulse              ;if so, display log
        CMP.B   #4, R4                   ;are we in the pulse menu?
        JZ      increasePulse            ;if so, display the heart

        JMP      fin
rightButtonPress:
        CMP.B   #1, R4                   ;are we in the options menu?
        JZ      displayRead              ;if so, display read
        CMP.B   #2, R4                   ;are we in the read menu?
        JZ      displayLog               ;if so, display log
        CMP.B   #3, R4                   ;are we in the log menu?
        JZ      displayRead              ;if so, display read

fin:
        BIC.B   #00000110B, &P1IFG
        NOP
        RETI
        
        END
